<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Plasma 일반인 개념 · Tokamak Network Documents</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# plasma-evm 일반인 간략 개념"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Plasma 일반인 개념 · Tokamak Network Documents"/><meta property="og:type" content="website"/><meta property="og:url" content="https://onther-tech.github.io/doc.tokamak.network/"/><meta property="og:description" content="# plasma-evm 일반인 간략 개념"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/doc.tokamak.network/img/tokamak_favicon.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/doc.tokamak.network/js/scrollSpy.js"></script><link rel="stylesheet" href="/doc.tokamak.network/css/main.css"/><script src="/doc.tokamak.network/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/doc.tokamak.network/"><img class="logo" src="/doc.tokamak.network/img/tokamak_white.png" alt="Tokamak Network Documents"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/doc.tokamak.network/docs/user-common" target="_self">Docs</a></li><li class=""><a href="/doc.tokamak.network/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>일반 사용자</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">일반 사용자</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/doc.tokamak.network/docs/user-common">일반 사용자 설명</a></li><li class="navListItem"><a class="navItem" href="/doc.tokamak.network/docs/user-manual">사용자 메뉴얼</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">개발자</h3><ul class=""><li class="navListItem"><a class="navItem" href="/doc.tokamak.network/docs/developer-manual">개발자 메뉴얼</a></li><li class="navListItem"><a class="navItem" href="/doc.tokamak.network/docs/developer-contribute">기여자 메뉴얼</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Stake &amp; Delegate</h3><ul class=""><li class="navListItem"><a class="navItem" href="/doc.tokamak.network/docs/stake-delegate">Stake &amp; Delegate</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Plasma 일반인 개념</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="plasma-evm-일반인-간략-개념"></a><a href="#plasma-evm-일반인-간략-개념" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>plasma-evm 일반인 간략 개념</h1>
<p>Tags: plasma-evm
Urgent?: Y
Writers: Jason Hwang, Aiden Park</p>
<ul>
<li><strong>간략한 개념 설명</strong>
<ul>
<li><p>plasma-evm as L-2 solution (다른 L-2 솔류션 비교)</p></li>
<li><p>enter / exit / <del>escape / undo</del> (뒤 두개는 TODO) (v)</p>
<ul>
<li><del>for what RootChain contract is</del></li>
</ul></li>
<li><p>Account system in plasma chain</p></li>
<li><p>continuous rebase (v)</p></li>
<li><p>stamina 설명 (v)</p>
<ul>
<li>stamina usecases</li>
</ul></li>
</ul></li>
</ul>
<h1><a class="anchor" aria-hidden="true" id="토카막-네트워크tokamak-network"></a><a href="#토카막-네트워크tokamak-network" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>토카막 네트워크(Tokamak Network)</h1>
<p>토카막 네트워크가 제공하고자 하는 것은 다양한 튜링 완전(Turing-Complete)한 플라즈마 블록체인을
손쉽게 만들어 낼 수 있는 프로토콜이다. 토카막 네트워크는 “임의의 상태”를 각각 다르게 변화시키기 위한
규칙을 루트체인(Root chain)에 별도로 정의하여 플라즈마 체인의 “올바른 상태 변화&quot; 기준을 마련
한다. 이는 확장된 상태 변화 시스템(레이어2)으로 플라즈마 블록체인의 활용 범위를 넓힌다. 따라서
토카막 네트워크는 이더리움 탈중앙화 어플리케이션(Decentralized Application; DApp)이 겪고 있는
확장성 문제를 해결할 수 있을 뿐만 아니라, 이더리움의 성능과 기능적 제약으로 인해 구현되지 못한
어플리케이션을 손쉽게 만들 수 있는 환경을 제공할 것이다.</p>
<ul>
<li>[ ]  dapp chain 용어? — 여러 dapp chain을 열고, TON을 enter해서 (P)ETH로 쓴다</li>
<li>[ ]  <em>이더리움의 성능과 기능적 제약으로 인해 구현되지 못한 어플리케이션을 손쉽게 만들 수 있는 환경을 제공할 것</em>이다. —&gt; 풀어 설명</li>
</ul>
<h1><a class="anchor" aria-hidden="true" id="what-is-plasma--플라즈마란-무엇인가"></a><a href="#what-is-plasma--플라즈마란-무엇인가" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Plasma? — 플라즈마란 무엇인가</h1>
<ul>
<li>[ ]  root chian ~ plasma chain 관계 다이어그램 (+RootChain contract, plasma block, ehtereum block)</li>
</ul>
<p>이더리움 재단의 조셉푼과 비탈릭 부테린에 의해서 제안된 플라즈마(링크)는 이더리움의 확장성 문제 해
결을 위한 모델이다. 플라즈마는 블록체인의 요약본을 주기적으로 이더리움 메인 체인에
제출하고, 이렇게 제출된 요약 증거를 바탕으로 플라즈마 블록에 문제가 생겼을 때 검증과정을 통해
이를 바로잡을 수 있다. 비탈릭이 직접 제안한 MVP, Cash 등의 초기 플라즈마 연구는 토큰 등의
단순전송과 이에 대한 검증에 초점이 맞춰져 있었으나 이후 플라즈마 Leap, EVM 등 일반
상태를 다루는 방향으로 발전 및 개선되고 있다.</p>
<h1><a class="anchor" aria-hidden="true" id="plasma-vs-sidechain"></a><a href="#plasma-vs-sidechain" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Plasma vs Sidechain</h1>
<p><a href="https://www.notion.so/0e1c92553eb6447e9b0844eead63757b">Untitled</a></p>
<h1><a class="anchor" aria-hidden="true" id="another-layer-2-solution"></a><a href="#another-layer-2-solution" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Another Layer 2 Solution</h1>
<ul>
<li>[ ]  ~~ 뭘 넣은건데 vvvvvvvv  참조할거다</li>
</ul>
<p><a href="https://www.notion.so/onther/Plasma-vs-optimistic-zk-Roll-up-5017e5f6044d45b49157d8351c27de88">https://www.notion.so/onther/Plasma-vs-optimistic-zk-Roll-up-5017e5f6044d45b49157d8351c27de88</a></p>
<h1><a class="anchor" aria-hidden="true" id="requestable-contract"></a><a href="#requestable-contract" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Requestable Contract</h1>
<ul>
<li><p>[ ]  Enter / Exit 개념 구분 설명 및 그림 추가</p></li>
<li><p>[ ]  순서: request → enter / exit → requestable contract</p></li>
<li><p>[ ]  vv 더 풀어쓰기?
e.g. 요청이란 양 체인간 데이터(혹은 자산)의 (이동)요청이다.</p></li>
</ul>
<p><strong>Request</strong>는 사용자가 <code>~~RootChain</code> 컨트랙트에~~ 플라즈마 체인으로 Enter/Exit을 하겠다는 요청을 담은 트랜잭션을 의미한다. <code>RootChain</code> 컨트랙트에 Request를 하려면 목적에 맞는 Enter/Exit 로직이 구현된 컨트랙트를 이용해야 하는데, 이에 대한 규칙을 정의한 컨트랙트를 Requestable 컨트랙트라고 한다. <del>Requestable 컨트랙트의 특정 함수를 호출 함으로써 루트 체인과 자식 체인에서 Request를 반영할 수 있다.</del> 각 컨트랙트 별로 Requestable 인터페이스를 개별적으로 구현하여야 한다. 예를들어 다양한 종류의 ERC20 토큰을 플라즈마 체인으로 Enter 하고자 한다면 각 토큰별로 Requestable 컨트랙트를 배포해야 하며 Requestable 컨트랙트에 대한 예시는 <a href="https://github.com/Onther-Tech/requestable-erc20-wrapper-token/blob/2d87d558e64257b94242b254c46581499cd3f777/contracts/RequestableERC20Wrapper.sol">여기서</a> 확인할 수 있다..</p>
<p>오퍼레이터는 RootChain 컨트랙트가 Request를 생성할 수 있도록 각 체인의 Requestable 컨트랙트의 주소를 사전에 연결해야 한다. 단, 각 체인의 Requestable 컨트랙트는 반드시 동일한 codeHash를 가져야 하며, 이는 두 컨트랙트가 같은 Storage 레이아웃을 갖는다는 것을 의미한다.</p>
<h2><a class="anchor" aria-hidden="true" id="request-and-request-transaction"></a><a href="#request-and-request-transaction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Request and Request Transaction</h2>
<ul>
<li>[ ]  개발자 - 기여자 파트로</li>
</ul>
<p><del>Request는 다음 4개의 파라미터로 구성된다.</del></p>
<ul>
<li><strong>~~requestor</strong>: Request를 생성한 어카운트~~</li>
<li><strong>~~to</strong>: 루트 체인에 배포된 Requestable contract의 주소~~</li>
<li><strong>~~trieKey</strong>: Request의 식별자~~</li>
<li><strong>~~trieValue</strong>: Request의 값~~</li>
</ul>
<p><del>Request 트랜잭션은 Request 블록에 포함되고 누구나 해당 블록을 마이닝 할 수 있어야 하기에 Null Address를 Transactor로 하여 생성된다. Null Address(NA)는 비밀키가 없으며 주소가 0x00다. Request transaction은 다음 5개의 파라미터로 구성된다.</del></p>
<ul>
<li><strong>~~sender</strong>: Null Address~~</li>
<li><strong>~~to</strong>: 자식 체인에 배포된 Requestable 컨트랙트의 주소~~</li>
<li><strong>~~value</strong>: 0~~</li>
<li><strong>~~function signature:</strong> Requestable 함수를 호출하기 위한 function signature~~</li>
<li><strong>~~parameters:</strong> Requestable 함수를 호출하기 위한 파라미터~~</li>
</ul>
<p><del>진입(Enter)이란 앞서 스마트 컨트랙트에 정의한 변수의 상태 변화 규칙에 모순되지 않는 방식으로 해당 변수를 루트체인에서 플라즈마 체인으로 옮기는 것을 뜻하고, 탈출(Exit)이란 그 반대의 상황을 뜻한다. 이더리움 시스템에 참여하는 참가자들이 만들어 낸 무한대에 가까운 상태 변수(State Variable)와 그 변경 요청(Apply Request Function)을 양 체인에 반영(Reflect)하기 위해서는 목적하는 변수에 맞는 진입(Enter)과 탈출(Exit)에 대한 로직이 구현되어 있는 컨트랙트를 요청가능 컨트랙트(Requestable Contract)라 하며 아래와 같은 인터페이스를 구현한다.</del></p>
<p><del>Requestable 컨트랙트에서 Request를 통해 변경이 가능한 변수는 요청 가능(Requestable)한 변수이다. 단, Requestable 컨트랙트의 모든 변수가 요청 가능(Requestable)일 필요는 없다. Request와 관련된 기능이 필요 없는 변수도 있고, 특정 변수에 대한 Request 권한을 사용자 별로 구분해야 하는 경우도 고려해야 하기 때문이다. 예를 들어, 누구나 타인의 토큰 밸런스에 대해 Request가 가능하다면 이는 바람직하지 않을 것이다. 따라서  trieKey를 이용하여 특정 변수에 대한 Request 권한을 확인 할 수 있게한다.</del></p>
<h1><a class="anchor" aria-hidden="true" id="enter-ton-to-tokamak-plasma-chain"></a><a href="#enter-ton-to-tokamak-plasma-chain" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enter TON to Tokamak Plasma Chain</h1>
<ul>
<li><p>[ ]  all requestable contracts</p></li>
<li><p>[ ]  TON -enter→PETH</p></li>
<li><p>[ ]  root chain ~ plasma chain 관계를 그림에 포함</p></li>
<li><p>[ ]  stamina 언급 ~ ref</p></li>
<li><p>[ ]</p>
<p>현재는 플라즈마 체인으로의 Enter/Exit은 <del>ERC20 토큰만 가능</del>하다. 이더리움 메인체인의 ERC20 토큰은 플라즈마 체인에 Enter 할 경우 플라즈마 체인의 ERC20 토큰인 <del>PERC20</del> 토큰이 된다. 하지만 TON은 토카막 플라즈마 체인에 Enter 할 경우 플라즈마 체인의 고유 화폐(Native currency)인 PETH가 된다. 즉, TON은 이더리움 메인 체인에서는 ERC20 토큰이지만, 토카막 플라즈마 체인 내에서는 이더와 같이 활용된다.</p></li>
</ul>
<p><strong>구조</strong></p>
<ul>
<li>TON 용처 설명
<ul>
<li>staking ref</li>
<li>stamina ref</li>
</ul></li>
<li>ENTER / EXIT
<ul>
<li>TON 및 requestable contract enter / exit 과정</li>
</ul></li>
<li>Stamina
<ul>
<li>자세한 설명</li>
<li>enter / exit</li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="entering-process"></a><a href="#entering-process" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Entering Process</h2>
<p>플라즈마 체인을 이용하기 위해 진입하는 절차는 다음과 같다. 모든 토큰은 Requestable 한 형태로 wrapping 되었고 플라즈마 체인에도 동일한 토큰 컨트랙트가 배포되고 메인체인의 토큰과 플라즈마 체인의 토큰이 RootChain 컨트랙트에 의해 매핑 된 상태라고 가정한다.</p>
<p><img src="plasma%20evm/Untitled.png" alt="plasma%20evm/Untitled.png"></p>
<ol>
<li>이더리움 체인에 배포된 RootChain 컨트랙트에 Enter Request를 한다. 이때 RootChain 컨트랙트의 주소, Enter할 토큰의 StorageKey, 그리고 Enter할 토큰의 수량을 입력해주어야 한다.</li>
<li>모든 값들이 올바르게 입력된다면 RootChain 컨트랙트가 Alice의 Enter Request를 반영한다.</li>
<li>플라즈마 체인에서 RootChain 컨트랙트에서 발생한 Enter 이벤트를 읽어온다.</li>
<li>플라즈마 체인에 배포된 ERC20 토큰이 발행되어 플라즈마 체인 내에 있는 계정에 Enter 한 양만큼 반영된다.</li>
</ol>
<p>위와 같은 과정이 모두 완료되면 플라즈마 체인으로 엔터한 자산이 플라즈마 체인에 반영되어 보유한 자산을 플라즈마 체인에서 사용할 수 있다.</p>
<h2><a class="anchor" aria-hidden="true" id="how-to-exit"></a><a href="#how-to-exit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How to Exit?</h2>
<p>Exit은 플라즈마 체인에 있는 자산을 다시 메인체인인 이더리움으로 옮기는 과정을 의미한다.</p>
<p><img src="plasma%20evm/Untitled%201.png" alt="plasma%20evm/Untitled%201.png"></p>
<ol>
<li>먼저 Alice는 메인체인에 있는 RootChain 컨트랙트에 해당 플라즈마 체인에서 Exit하겠다는 요청을 보낸다.</li>
<li>플라즈마 체인에서 Exit 이벤트를 읽는다</li>
<li>플라즈마 체인에서 Exit 이벤트가 반영되어 플라즈마 체인에 있는 자산이 소각된다.</li>
<li>그 다음 메인체인인 이더리움에서 플라즈마 체인에서 Exit 한 자산이 반영된다.</li>
</ol>
<p>Exit 과정을 거치면 플라즈마 체인에서 사용하고 있던 자산을 메인체인으로 옮겨서 사용할 수 있다.</p>
<h2><a class="anchor" aria-hidden="true" id="transaction-type-of-tokamak"></a><a href="#transaction-type-of-tokamak" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transaction Type of Tokamak</h2>
<p><a href="https://www.notion.so/5221a297db204db9b687029ca37973a5">Untitled</a></p>
<h1><a class="anchor" aria-hidden="true" id="stamina"></a><a href="#stamina" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stamina</h1>
<p>Tokamak Network의 사용자는 톤(TON)을 예치해 플라즈마 체인에서 일정한 기간동안, 일정한 양의 트랜잭션을 일으킬 수 있는 권리인 “스태미나”를 만들 수 있다. 이더리움에서 트랜잭션을 전송하면 해당 계정의 소량의 이더를 가스비로 차감하는 것과 달리 Tokamak Network에서 스태미나를 이용하여 트랜잭션을 전송할 경우 갖고 있는 자산 대신 스태미나를 소모하여 트랜잭션을 전송할 수 있다. 또한 스태미나는 일정 기간이 지나면 회복되기 때문에 사용자들은 자산이 없는 상태에서도 트랜잭션을 보낼 수 있다.
스태미나는 일정한 기간이 지나면 재생된다. 이러한 방식의 수수료 차감 정책은 마치 사용자가
일정한 기간 동안 플라즈마 블록 체인을 사용할 수 있는 “대역폭(Bandwidth)”을 임차하는 것과 같으며,
임차비용은 해당 기간동안 스태미나 사용을 위해 예치한 톤(TON)의 시간 기회비용으로 볼 수 있다.
톤(TON)을 통해 만들어진 스태미나는 이를 거치한 사용자 본인의 계정 뿐만아니라, 다른 계정으로
빌려주는 것 또한 가능하다. 이렇게 만들어진 위임자-수임자 관계의 계정을 스태미나 쌍(Stamina Pair)
이라 칭한다.</p>
<hr>
<h1><a class="anchor" aria-hidden="true" id="stamina-1"></a><a href="#stamina-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stamina</h1>
<p><code>스태미나(Stamina)</code>는 위임계정(delegator)이 본 트랜잭션 실행 모델을 구동시킬 때 필요한 가스비를 수임계정(delegatee)에게 청구할 때 사용된다. 즉 위임계정(delegator)의 가스비를 수임계정(delegatee)이 스태미나(Stamina)의 형태로 구매하여 위임계정의 가스비 부담을 대신하게 된다. 스태미나는 스태미나 컨트랙트(Stamina contract)에 계정 잔액(state balance)을 예치(deposit)함으로써 얻을 수 있는데, 수임계정의 스태미나를 예치(deposit)한 계정을 <code>예치 계정(depositor account)</code>이라 부른다.</p>
<p>수임계정의 스태미나는 위임계정의 가스비를 구매 하면서 차감된다. 차감된 스태미나는 영원히 사라지는 것이 아니라 일정 기간이 지나면 회복(recover)되는데, 이를 PoC1에서는 <code>스태미나 회복(stamina recover)</code>이라 부른다. 스태미나가 회복 되기 위해서는 일정 기간이 필요한데, 이 기간을 <code>회복 기간(RECOVER EPOCH LENGTH)</code>이라 부르고, 다음 기간(EPOCH)에서 수임계정에 총 예치된 양만큼의 스태미나가 새롭게 충전된다.</p>
<h3><a class="anchor" aria-hidden="true" id="스태미나-컨트랙트"></a><a href="#스태미나-컨트랙트" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>스태미나 컨트랙트</strong></h3>
<p>스태미나 컨트랙트는 수수료 위임 모델에 있어서 중요한 컨트랙트다. 스태미나 컨트랙트는 다음 기능을 제공한다.</p>
<ol>
<li>위임계정(delegator) 지정</li>
<li>스태미나 증감(increase/decrease)</li>
<li>스태미나 환불/차감/회복(refund/subtract/recover)</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="위임계정-지정"></a><a href="#위임계정-지정" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>위임계정 지정</strong></h3>
<p>수임 계정(delegatee)은 위임 계정(delegator)을 지정할 수 있다. 오직 수임 계정(delegatee)만 위임 계정(delegator)을 지정할 수 있으며, 이 반대로 위임계정(delegator)은 수임 계정(delegatee)을 지정할 수 없다. 더해서 수임 계정(delegatee)은 여럿의 위임 계정(delegator)을 지정할 수 있다.</p>
<p>수임계정이 위임계정을 지정하게 되면 쌍(pair)이 형성되는데 이를 <code>스태미나 쌍(stamina pair)</code> 또는 <code>수수료 위임 쌍(fee-delegate pair)</code>이라 부른다. 수임계정(delegatee)는 위임계정(delegator)을 지정하기 위해서 스테미나 컨트랙트의 <code>setDelegator()</code> 함수를 호출한다.</p>
<h3><a class="anchor" aria-hidden="true" id="스테미나-증감increasedecrease"></a><a href="#스테미나-증감increasedecrease" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>스테미나 증감(increase/decrease)</strong></h3>
<p>수임계정은 위임계정의 가스비를 구매하기 위해서 스태미나가 필요하다. 수임계정은 가지고 있는 스태미나의 양만큼 위임계정의 가스비를 대신 부담할 수 있다. 수임계정의 스태미나 소모량은 위임계정의 수 또는 트랜잭션 가스비와 비례할 가능성이 높다. 따라서 예치계정은 위임계정의 수와 트랜잭션 가스비에 맞게 수임계정의 스태미나를 늘리거나 줄일 것이다.</p>
<p>스태미나를 늘리기 위해서 예치계정(depositor)은 스태미나 컨트랙트의 <code>deposit()</code> 함수를 호출해야 한다. 예치계정은 예치(deposit)할 만큼의 계정잔액을 예치하고 수임계정은 예치한 만큼의 계정 잔액(state balance)을 추가적인 스태미나로 보유하게 된다.</p>
<p>이와 반대로 수임계정의 스태미나를 출금(withdraw) 받기 위해서는 스태미나 컨트랙트의 <code>withdraw()</code> 함수(더 정확하게는 <code>requestWithdrawl()</code>, <code>withdraw()</code> 함수)를 사용한다. 이 때 스태미나는 줄어들고 줄어든 스태미나만큼 수임계정에게 계정 잔액이 출금(withdraw)된다.</p>
<p>수임계정이 스태미나를 출금(withdraw)하기 위해서 두 단계(<a href="https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls">Favor pull over push payments</a>)를 거친다.</p>
<ol>
<li><code>requestWithdrawl()</code> 함수 호출: 먼저 예치계정(depositor)의 컨트랙트의 <code>requestWithdrawal()</code> 함수를 호출한다. 이를 호출하게 되면 수임 계정의 스태미나는 요청한 양만큼 차감되고 이에 대한 기록은 스태미나 컨트랙트에 남게 된다.</li>
<li><code>withdraw()</code> 함수 호출: 예치계정은 <code>withdraw()</code> 함수를 호출하여 <code>requestWithdrawl()</code> 함수를 통해 기록된 정보를 이용해 차감한 스태미나만큼 계정 잔액을 채운다.</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="스테미나-차감환불회복subtractrefundrecover"></a><a href="#스테미나-차감환불회복subtractrefundrecover" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>스테미나 차감/환불/회복(subtract/refund/recover)</strong></h3>
<p>이더리움에서는 트랜잭션을 처리하기 위해서 거래 생성자(transactor)의 잔액(Balance)으로 트랜잭션의 가스비를 구매하고 구매한 가스비로 트랜잭션을 처리 후에 남은 가스비는 다시 거래 생성자(transactor)에게 계정 잔액(ETH)을 되돌려준다. 이와 마찬가지로 스태미나 또한, 위임계정이 생성한 트랜잭션의 가스 예산(gas-upfront cost)만큼 스태미나를 차감한 후에 수행 후 남은 스태미나를 환불(refund)해준다. 스태미나의 차감은 스태미나 컨트랙트의 <code>subtractStamina()</code> 함수를 호출 함으로써 이루어진다.</p>
<p><code>subtractStamina()</code> 함수는 onlyChain modifier를 가진다. 이 onlyChain modifier를 가지는 함수는 NULL_ADDRESS만이 직접 호출할 수 있고 다른 계정에서는 직접 호출할 수 없다.</p>
<p>스태미나로 가스비를 구매하여 트랜잭션을 처리한 후 남은 가스비는 수임계정에게 환불(refund)된다. 이 또한 널-계정(NULL_ADDRESS)이 스태미나 컨트랙트 함수를 호출 함으로써 이루어지는데 <code>addStamina()</code> 함수를 호출하게 된다. <code>addStamina()</code> 함수 안에는 회복량(recoverery amount)을 확인하는 로직도 포함되어 있다.</p>
<p>수임계정(delegatee)의 스태미나는 위임계정(delegator)의 가스비를 구매 하면서 결국 고갈될 것이다. 하지만 고갈된 스태미나는 다음 회복 기간(EPOCH)에 새로 충전된다. 즉 수임계정은 가지고 있는 스태미나를 다 사용해도 다음 회복기간(EPOCH)에서 새로 스태미나가 충전되기 때문에 스태미나를 재 사용할 수 있다. 스태미나 회복은 스태미나가 환불될 때 자동으로 수행된다. 스태미나를 환불하는 과정에서 회복 기간이 돌아왔는지(RECOVER EPOCH LENGTH) 체크한 후 해당될 경우 스태미나를 다시 회복 해준다. 회복되는 스태미나의 양은 수임자가 예치한 계정잔액의 총량과 같다.</p>
<ul>
<li>[ ]  delegator - delegatee 관계 + tx.sender, fee 지불자 관계</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="스태미나-위임-형태"></a><a href="#스태미나-위임-형태" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>스태미나 위임 형태</h3>
<p>depositor = delegator = delegatee — self-deposit &amp; self-delegation</p>
<p>depositor = delegator → delegatee — self-deposit &amp; delegate to other</p>
<p>depositor → delegator → delegatee — deposit to other &amp; delegate to other</p>
<p>depositor → delegator = delegatee — deposit to other &amp; self-delegation</p>
<ul>
<li>[ ]  개조식으로 재구성</li>
</ul>
<p>스태미나를 위임하는 형태는 세 가지가 있다.</p>
<p>첫 번째는 depositor, 수임 계정, 위임 계정이 모두 같은 경우이다. 이 경우는 특정 계정이 자기 자신을 수임 계정으로 삼아 본인 계정에 스태미나를 예치하고</p>
<h3><a class="anchor" aria-hidden="true" id="비위임-실행normal-execution"></a><a href="#비위임-실행normal-execution" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>비위임 실행(normal execution)</strong></h3>
<p>비위임 실행은 기존의 이더리움 체인에서의 트랜잭션 처리 과정과 같으며, 다음의 절차를 거친다.</p>
<ol>
<li>트랜잭션 실행자(transactor)의 잔액을 조회 : 트랜잭션을 생성한 계정의 잔액을 state.balance에서 불러온다.</li>
<li>트랜잭션 지불 예산(upfront cost) 감당 가능여부를 판단</li>
<li>지불 예산(upfront cost) 차감</li>
<li>가상머신실행</li>
<li>환불 가스(refunded gas) 지급</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="위임-실행delegated-execution"></a><a href="#위임-실행delegated-execution" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>위임 실행(delegated execution)</strong></h3>
<p>위임실행의 경우 다음의 과정을 거친다.</p>
<ul>
<li>트랜잭션 생성 계정(transactor)이 위임할 수 있는 수임계정이 존재하는지 확인한다(위임계정이 스태미나 쌍에 포함되어 있는지 여부를 확인한다.)
<ol>
<li>(수임계정이 있을 경우)
<ol>
<li>수임계정의 가스 예산(gas-upfront cost) 감당 가능 여부를 판단</li>
<li>수임계정에게서 가스예산에 해당하는 스테미나를 차감</li>
<li>트랜잭션 생성 계정의 잔액에서 금액 예산(value-upfront cost)을 차감</li>
<li>가상머신 실행</li>
<li>환불 가스(refunded gas)만큼의 스태미나를 수임계정에게 환불</li>
</ol></li>
<li>(수임계정이 없을 경우)
<ol>
<li>비위임 실행(2.2.2 상술)</li>
</ol></li>
</ol></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="기존-이더리움의-실행모델과-비교"></a><a href="#기존-이더리움의-실행모델과-비교" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><strong>기존 이더리움의 실행모델과 비교</strong></h3>
<p><a href="https://www.notion.so/fcf8d5b09a034daa90f859c332068252">Untitled</a></p>
<h1><a class="anchor" aria-hidden="true" id="continuous-rebase"></a><a href="#continuous-rebase" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Continuous Rebase</h1>
<ul>
<li>[ ]  named after &quot;git rebase&quot; + 다른 현실적인 비유?</li>
</ul>
<p>Continuous Rebase 모델은 플라즈마 체인의 정상적인 작동과정에 <strong>Rebase</strong>를 포함시킨다. 따라서 지속적이고 주기적인 Rebase를 통해 사용자들의 <strong>Escape Request</strong>를 반영할 수 있게 한다.</p>
<p>이를 통해 사용자들은 DA문제가 있을 경우 Escape Request를 제출하여 안전하게 탈출할 수 있다. 또한 제출된 블록이 올바르지 않을 경우 Computation Challenge를 통해 해당 블록들이 Finalize 되는 것을 막을 수 있다.</p>
<h2><a class="anchor" aria-hidden="true" id="what-is-escape-request"></a><a href="#what-is-escape-request" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Escape Request?</h2>
<p>플라즈마 체인의 Data availability에 문제가 생겼을 경우에 사용자가 제출하는 긴급탈출 요청</p>
<p>*구조적으로 Exit Request와 동일하다.</p>
<ul>
<li>[ ]  exit 과 차이 / 공통점</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="what-is-undo-request"></a><a href="#what-is-undo-request" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Undo Request?</h2>
<p>undo의 목적: enter request를 막는다</p>
<h2><a class="anchor" aria-hidden="true" id="what-is-rebase"></a><a href="#what-is-rebase" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is Rebase?</h2>
<p>Rebase는 기존에 루트체인에 제출한 블록을 다른 블록을 기준으로 다시 마이닝 하는 것</p>
<p>pre-commit → commit 으로 변경되는 점 기술</p>
<h2><a class="anchor" aria-hidden="true" id="cycle-of-continuous-rebase"></a><a href="#cycle-of-continuous-rebase" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cycle of Continuous Rebase</h2>
<p><img src="plasma%20evm/Untitled%202.png" alt="plasma%20evm/Untitled%202.png"></p>
<ol>
<li><p><strong>Pre-commit</strong>: 오퍼레이터가 플라즈마 체인의 블록을 마이닝한 후 각 블록의 txRoot 제출</p></li>
<li><p><strong>DA check</strong>: 사용자가 Pre-commit 과정의 DA check, 문제시 Escape Request 제출</p></li>
<li><p><strong>Commit</strong>: Process Escape, Rebase의 과정을 수행</p>
<p>3-1. <strong>Process Escape</strong>: 1,2 에서 제출된 Escape Request를 포함한 Escape Block 마이닝 후 제출</p>
<p>3-2. <strong>Rebase</strong>: Escape Block을 기준으로 Pre-commit된 블록 Rebase</p></li>
<li><p><strong>Challenge</strong>: Commit 된 블록에 대한 챌린지 제출</p></li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="pre-commit"></a><a href="#pre-commit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><del>Pre-commit</del></h3>
<p><del>NRB와 ORB가 생성된 후 사용자들에게 전파되는 단계이며 이때 txRoot가 루트체인에 제출된다. Pre-commit 에서 제출된 블록들은 rebase로 인해 stateRoot와 receiptRoot가 변경될 수 있기 때문에 포함되지 않으며, 해당 블록에 포함될 트랜잭션들에 대해 알고 있다면 stateRoot와 receiptRoot는 연산할 수 있기 때문에 사용자들은 Commit 단계에서 오퍼레이터가 데이터를 숨기고 잘못된 stateRoot를 제출하더라도 이를 알아차리고 Challenge를 할 수 있다.</del></p>
<h3><a class="anchor" aria-hidden="true" id="da-check"></a><a href="#da-check" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><del>DA check</del></h3>
<p><del>사용자가 Pre-commit 단계에서 DA 문제가 없는지 확인하는 단계이다. 이때 문제가 발견된다면 Escape Request를 제출하여 안전하게 탈출할 수 있다. 이 단계의 목적은 DA 문제에 대한 인지 및 대처할 수 있는 시간을 사용자들에게 주는 것에 있으며, 만약 Escape Request를 제출하려 한다면 Pre-commit 단계에서 제출된 Exit Request나 Enter Request가 없어야 한다. 만약 Pre-commit 단계에서 제출한 Enter Request나 Exit Requset가 있다면, Enter Request의 경우 Undo Request를 제출해서 Enter를 취소해야 하며, Exit Request는 취소해야 한다. Escape Request 이후에 같은 해당 사용자의 Exit Request가 실행된다면 해당 Request는 revert될것이고 비정상적인 Exit으로 판단되어 Exit Request의 대상이 될 수 있다.</del></p>
<h3><a class="anchor" aria-hidden="true" id="commit"></a><a href="#commit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><del>Commit</del></h3>
<p><del>Commit은 두 종류의 행위(?)가 이루어 지는 단계이다. 첫 번째는 오퍼레이터가 Pre-commit과 DA-check에서 제출된 Escape Request와 Undo Request를 반영하는 Escape block(EB)를 제출한다. 이 과정에서   Escape Request를 제출한 사용자들은 안전하게 플라즈마 체인에서 탈출하고, Undo Request를 제출한 사용자들은 루트체인에서 수행한 Enter를 취소할 수 있다. 두 번째는 EB를 바탕으로 Pre-commit 단계에서 제출된 모든 블록들을 Rebase하는 것이다. Rebase가 끝난 후에는 Pre-commit된 블록의 stateRoot와 receiptRoot를 제출한다. 만약 해당 Cycle에서 제출된 Escape Request가 없다면, EB 제출과 Rebase는 생략된다.</del></p>
<h3><a class="anchor" aria-hidden="true" id="challenge"></a><a href="#challenge" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><del>Challenge</del></h3>
<p><del>Commit 단계에서 제출된 블록이 유효하지 않을 수 도 있다. 그럴 때 사용자들에게 최후의 수단으로 Challenge를 할 수 있는 기회가 주어진다. 이때 제출 가능한 Challege는 Null Address Challenge, Computation Challenge이다. 한 Challenger가 승리하면 다른 Challenge는 취소되며, 해당 Cycle은 DA check 단계로 되돌아간다.</del></p>
<h3><a class="anchor" aria-hidden="true" id="finalize"></a><a href="#finalize" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><del>Finalize</del></h3>
<p><del>Challenge까지 무사히 완료되었다면, 해당 Cycle은 Finalize되며, Commit 단계에서 제출된 모든 블록이 동시에 Finalize된다.</del></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/doc.tokamak.network/docs/user-manual"><span>사용자 메뉴얼</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#request-and-request-transaction">Request and Request Transaction</a></li><li><a href="#entering-process">Entering Process</a></li><li><a href="#how-to-exit">How to Exit?</a></li><li><a href="#transaction-type-of-tokamak">Transaction Type of Tokamak</a><ul class="toc-headings"><li><a href="#스태미나-컨트랙트"><strong>스태미나 컨트랙트</strong></a></li><li><a href="#위임계정-지정"><strong>위임계정 지정</strong></a></li><li><a href="#스테미나-증감increasedecrease"><strong>스테미나 증감(increase/decrease)</strong></a></li><li><a href="#스테미나-차감환불회복subtractrefundrecover"><strong>스테미나 차감/환불/회복(subtract/refund/recover)</strong></a></li><li><a href="#스태미나-위임-형태">스태미나 위임 형태</a></li><li><a href="#비위임-실행normal-execution"><strong>비위임 실행(normal execution)</strong></a></li><li><a href="#위임-실행delegated-execution"><strong>위임 실행(delegated execution)</strong></a></li><li><a href="#기존-이더리움의-실행모델과-비교"><strong>기존 이더리움의 실행모델과 비교</strong></a></li></ul></li><li><a href="#what-is-escape-request">What is Escape Request?</a></li><li><a href="#what-is-undo-request">What is Undo Request?</a></li><li><a href="#what-is-rebase">What is Rebase?</a></li><li><a href="#cycle-of-continuous-rebase">Cycle of Continuous Rebase</a><ul class="toc-headings"><li><a href="#pre-commit"><del>Pre-commit</del></a></li><li><a href="#da-check"><del>DA check</del></a></li><li><a href="#commit"><del>Commit</del></a></li><li><a href="#challenge"><del>Challenge</del></a></li><li><a href="#finalize"><del>Finalize</del></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/doc.tokamak.network/" class="nav-home"></a><div><h5>Docs</h5><a href="/doc.tokamak.network/docs/en/user-common">Common User</a></div><div><h5>Community</h5><a href="https://chat.toakamak.com/">Chat Tokemak</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="http://blog.onther.io">Onther Blog</a><a href="https://github.com/onther-tech/">Onther GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/onther-tech/plasma-evm" data-show-count="true" data-count-aria-label="# plasma-evm on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://tokamak.network" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/doc.tokamak.network/img/tokamak_white.png" alt="Tokamak Network" width="200%" height="200%"/></a><section class="copyright">Copyright © 2019 Onther Inc.</section></footer></div></body></html>