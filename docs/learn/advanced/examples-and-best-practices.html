<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>요청 가능한 컨트랙트 예제 · Tokamak Network Documents</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; Continuous Rebase는 아직 개발중으로 본 문서에서는 해당 기능이 빠진 컨트랙트 구현을 다룹니다."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="요청 가능한 컨트랙트 예제 · Tokamak Network Documents"/><meta property="og:type" content="website"/><meta property="og:url" content="https://onther-tech.github.io/"/><meta property="og:description" content="&gt; Continuous Rebase는 아직 개발중으로 본 문서에서는 해당 기능이 빠진 컨트랙트 구현을 다룹니다."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/tokamak_favicon.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/prism.css"/><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/tokamak_white.png" alt="Tokamak Network Documents"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/learn/basic/tokamak-network" target="_self">Docs</a></li><li class="siteNavGroupActive"><a href="/docs/guides/getting-started/how-to-open-private-testnet-rootchain" target="_self">Getting Started</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>고급</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">배우기<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">기초</h4><ul><li class="navListItem"><a class="navItem" href="/docs/learn/basic/tokamak-network">토카막 네트워크</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/basic/enter-and-exit">상호운용성: 진입 &amp; 퇴장</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/basic/transaction-fee">편의성: 계정, 트랜잭션 수수료, 개발도구</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/basic/layer-2-solutions">비교: 다른 확장성 솔루션</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">고급</h4><ul><li class="navListItem"><a class="navItem" href="/docs/learn/advanced/design-rationale">디자인 원칙</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/advanced/plasma-evm-architecture">Plasma EVM 아키텍처</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/advanced/root-chain">루트체인</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/advanced/child-chain">자식체인</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/advanced/continuous-rebase">Continuous Rebase</a></li><li class="navListItem"><a class="navItem" href="/docs/learn/advanced/plasma-evm-smart-contracts">Plasma EVM 스마트 컨트랙트</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/learn/advanced/examples-and-best-practices">요청 가능한 컨트랙트 예제</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">가이드<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">프라이빗 테스트넷 시작하기</h4><ul><li class="navListItem"><a class="navItem" href="/docs/guides/getting-started/how-to-open-private-testnet-rootchain">루트체인 설정하기</a></li><li class="navListItem"><a class="navItem" href="/docs/guides/getting-started/how-to-open-private-testnet-manually">직접 설정하기</a></li><li class="navListItem"><a class="navItem" href="/docs/guides/getting-started/how-to-open-private-testnet-puppeth">Puppeth 사용하여 설정하기</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">퍼블릭 테스트넷 연결하기</h4><ul><li class="navListItem"><a class="navItem" href="/docs/guides/getting-started/how-to-connect-public-testnet-prepare">연결 준비하기</a></li><li class="navListItem"><a class="navItem" href="/docs/guides/getting-started/how-to-connect-public-testnet-manually">직접 연결하기</a></li><li class="navListItem"><a class="navItem" href="/docs/guides/getting-started/how-to-connect-public-testnet-puppeth">Puppeth 사용하여 연결하기</a></li></ul></div><li class="navListItem"><a class="navItem" href="/docs/guides/public-testnets">퍼블릭 테스트넷 정보</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/onther-tech/doc.tokamak.network/edit/master/docs/learn/advanced/examples-and-best-practices.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">요청 가능한 컨트랙트 예제</h1></header><article><div><span><blockquote>
<p>Continuous Rebase는 아직 개발중으로 본 문서에서는 해당 기능이 빠진 컨트랙트 구현을 다룹니다.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="counter"></a><a href="#counter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Counter</h2>
<p>단순히 숫자가 증가만 하는 카운터 컨트랙트를 살펴봅시다. 우선 기본적인 기능을 하는 <code>BaseCounter</code> 컨트랙트부터 Requestable 기능을 추가할 것입니다. 이 항목의 구성은 각 예시에서 발생하는 문제점들에 따라 점차 개선하는 방식으로 진행됩니다.</p>
<h3><a class="anchor" aria-hidden="true" id="basecounter"></a><a href="#basecounter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BaseCounter</h3>
<pre><code class="hljs css language-solidity">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.24</span>;


contract BaseCounter {
  <span class="hljs-keyword">uint</span> n;

  event Counted(<span class="hljs-keyword">uint</span> _n);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-title">external</span> </span>{
    n++;
    emit Counted(n);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-title">external</span> <span class="hljs-title">view</span> <span class="hljs-title">returns</span> <span class="hljs-params">(uint)</span> </span>{
    <span class="hljs-keyword">return</span> n;
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="simplecounter"></a><a href="#simplecounter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SimpleCounter</h3>
<p>먼저 가장 간단하게 Requestable을 고려한다면 상태 변수 <code>n</code>을 enter 혹은 exit 요청에 따라 증감시키는 구조입니다. 컨트랙트는 아래와 같은 방식으로 동작합니다.</p>
<p><img src="https://i.imgur.com/GQaEylR.png" alt=""></p>
<!-- A yellow box means that the counter() has increased the status variable n by 1, a red box means entering the request changes n, and a green box means exiting the request changes n. -->
<p><em>노란색 네모</em>는 <code>counter()</code> 함수로 <code>n</code>이 1씩 증가하는 것, <em>빨간색 네모</em>는 enter 요청으로 변경된 <code>n</code>의 값을, <em>초록색 네모</em>는 exit 요청으로 변경된 <code>n</code>의 값을 가리킵니다.</p>
<pre><code class="hljs css language-solidity">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.24</span>;

<span class="hljs-keyword">import</span> {SimpleDecode} <span class="hljs-keyword">from</span> "../lib/SimpleDecode.sol";
<span class="hljs-keyword">import</span> {RequestableI} <span class="hljs-keyword">from</span> "../lib/RequestableI.sol";
<span class="hljs-keyword">import</span> {BaseCounter} <span class="hljs-keyword">from</span> "./BaseCounter.sol";
<span class="hljs-keyword">import</span> {SafeMath} <span class="hljs-keyword">from</span> "openzeppelin-solidity/contracts/math/SafeMath.sol";


/// @<span class="hljs-keyword">notice</span> A request can decrease `n`. But, <span class="hljs-keyword">is</span> it right <span class="hljs-keyword">to</span> decrease the count?
contract SimpleCounter <span class="hljs-keyword">is</span> BaseCounter, RequestableI {
  // SimpleDecode library <span class="hljs-keyword">to</span> decode trieValue.
  <span class="hljs-keyword">using</span> SimpleDecode <span class="hljs-keyword">for</span> bytes;
  <span class="hljs-keyword">using</span> SafeMath <span class="hljs-keyword">for</span> *;

  // trie key <span class="hljs-keyword">for</span> state variable `n`.
  bytes32 <span class="hljs-keyword">constant</span> <span class="hljs-built_in">public</span> TRIE_KEY_N = <span class="hljs-number">0x00</span>;

  // address <span class="hljs-keyword">of</span> RootChain contract.
  address <span class="hljs-built_in">public</span> rootchain;

  <span class="hljs-keyword">mapping</span> (uint =&gt; <span class="hljs-type">bool</span>) appliedRequests;

  constructor(address _rootchain) {
    rootchain = _rootchain;
  }

  <span class="hljs-keyword">function</span> applyRequestInRootChain(
    <span class="hljs-type">bool</span> isExit,
    uint256 requestId,
    address requestor,
    bytes32 trieKey,
    bytes trieValue
  ) <span class="hljs-keyword">external</span> <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span> success) {
    require(!appliedRequests[requestId]);
    require(msg.sender == rootchain);

    // <span class="hljs-keyword">only</span> accept request <span class="hljs-keyword">for</span> `n`.
    require(trieKey == TRIE_KEY_N);

    <span class="hljs-keyword">if</span> (isExit) {
      n = n.<span class="hljs-keyword">add</span>(trieValue.toUint());
    } <span class="hljs-keyword">else</span> {
      n = n.sub(trieValue.toUint());
    }

    appliedRequests[requestId] = <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-keyword">function</span> applyRequestInChildChain(
    <span class="hljs-type">bool</span> isExit,
    uint256 requestId,
    address requestor,
    bytes32 trieKey,
    bytes trieValue
  ) <span class="hljs-keyword">external</span> <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span> success) {
    require(!appliedRequests[requestId]);
    require(msg.sender == address(<span class="hljs-number">0</span>));

    // <span class="hljs-keyword">only</span> accept request <span class="hljs-keyword">for</span> `n`.
    require(trieKey == TRIE_KEY_N);

    <span class="hljs-keyword">if</span> (isExit) {
      n = n.sub(trieValue.toUint());
    } <span class="hljs-keyword">else</span> {
      n = n.<span class="hljs-keyword">add</span>(trieValue.toUint());
    }

    appliedRequests[requestId] = <span class="hljs-keyword">true</span>;
  }
}
</code></pre>
<!-- However, SimpleCounter may decrease with variable n due to enter and exit. If this is not desired, you can implement counter contract as below. -->
<p><code>SimpleCounter</code>는 <code>n</code>을 각 요청에 따라 증감시킵니다. 이 경우 총 카운터를 계산하기 위하여 양 체인의 두 컨트랙트를 모두 참조해야합니다. 또한 <code>n</code>이 감소하는 카운터가 바람직한지 고려해야합니다. 이 두가지를 고려한다면 단순히 한 쪽 체인에서만 카운터가 동작할 수 있도록 할 수 있습니다.</p>
<h3><a class="anchor" aria-hidden="true" id="freezablecounter"></a><a href="#freezablecounter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>FreezableCounter</h3>
<!-- Enter and exit can be applied after freezing the contracts in each chain. FreezableCounter can be avoided if the number decreases through the request method after freezing. -->
<p>자식 체인에서는 기본적으로 카운터가 멈춰있는 상태로 시작합니다. 루트 체인에서 enter 요청이 생성될 경우 루트 체인의 카운터가 동작을 멈추고 요청이 반영된 순간 자식 체인의 카운터가 동작합니다. exit 요청의 경우 자식 체인의 카운터를 멈추고 부모 체인의 카운터를 동작시킵니다. 이를 통해 <code>n</code>이 감소하는 것을 막을 수 있습니다.</p>
<p><img src="https://i.imgur.com/IDHhZRs.png" alt=""></p>
<pre><code class="hljs css language-solidity">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.24</span>;

<span class="hljs-params">...</span>


<span class="hljs-comment">/// @notice Both contract may be frozen at the same time. Is it right?</span>
contract FreezableCounter is BaseCounter, RequestableI {
  <span class="hljs-params">...</span>

  <span class="hljs-comment">// freeze counter before make request.</span>
  bool <span class="hljs-keyword">public</span> <span class="hljs-keyword">frozen</span>;

  constructor(address _rootchain) {
    rootchain = _rootchain;

    <span class="hljs-comment">// Counter in child chain is frozen at first.</span>
    <span class="hljs-keyword">if</span> (_rootchain == address(<span class="hljs-number">0</span>)) {
      <span class="hljs-keyword">frozen</span> = <span class="hljs-literal">true</span>;
    }
  }

  function freeze() external returns (bool success) {
    <span class="hljs-keyword">frozen</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  function applyRequestInRootChain(
    bool isExit,
    uint256 requestId,
    address requestor,
    bytes32 trieKey,
    <span class="hljs-built_in">bytes</span> trieValue
  ) external returns (bool success) {
    <span class="hljs-params">...</span>
    <span class="hljs-keyword">require</span>(<span class="hljs-keyword">frozen</span>);

    <span class="hljs-params">...</span>

    <span class="hljs-keyword">if</span> (isExit) {
      <span class="hljs-keyword">frozen</span> = <span class="hljs-literal">false</span>;
      n = trieValue.toUint();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">require</span>(n == trieValue.toUint());
    }

    <span class="hljs-params">...</span>
  }

  function applyRequestInChildChain(
    bool isExit,
    uint256 requestId,
    address requestor,
    bytes32 trieKey,
    <span class="hljs-built_in">bytes</span> trieValue
  ) external returns (bool success) {
    <span class="hljs-params">...</span>
    <span class="hljs-keyword">require</span>(<span class="hljs-keyword">frozen</span>);

    <span class="hljs-params">...</span>

    <span class="hljs-keyword">if</span> (isExit) {
      <span class="hljs-keyword">require</span>(n == trieValue.toUint());
    } <span class="hljs-keyword">else</span> {
      n = trieValue.toUint();
      <span class="hljs-keyword">frozen</span> = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-params">...</span>
  }
}
</code></pre>
<!-- However, the challenge period exists until exit is applied in root chain, for this freeze counter, all counters in each chain are frozen before the end of this challenge period. The enter is relatively short, but both are frozen. Therefore, to prevent this, the state variable used for enter and the state variable used for exit must be different. -->
<p>이 구현체의 경우 가장 큰 문제는 exit 요청이 부모 체인에 반영될 때 블록과 요청에 대햔 챌린지 기간을 가진다는 점입니다. 따라서 exit 요청이 finalize되기 전에는 양 체인의 모든 카운터가 멈춰있는 상태입니다. 또한 한 체인의 동작을 멈출 수 밖에 없기에 <code>FreezableCounter</code>에 대해 enter 혹은 exit 요청을 보내는 것은 특정 어카운트만 수행할 수 있도록 권한을 줘야한다는 단점이 있습니다. 이를 방지하기 위하여 &quot;요청으로 인해 <code>n</code>이 얼마나 변경 되었는가&quot;를 별도의 상태 변수로 관리해야 합니다.</p>
<h3><a class="anchor" aria-hidden="true" id="trackablecounter"></a><a href="#trackablecounter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TrackableCounter</h3>
<!-- TrackableCounter checks whether enter and exit is possible through a separate state variable requestableN in enter in the root chain and exit in child chain, reduces the value, and increases n in exit in the root chain and enter in the child chain. Both operations can prevent the reduction of n and apply only the correct enter and exit. -->
<p><code>TrackableCounter</code>는 다른 체인에 값을 전달할 수 있는가를 별도의 상태변수 <code>requestableN</code>을 통해 관리합니다. <code>counter()</code>는 기존의 <code>n</code>과 <code>requestableN</code>를 동시에 증가시키며, 부모 체인에서의 enter(혹은 자식 체인에서의 exit)의 경우 해당 체인에서는 <code>requestableN</code>만 감소시킵니다. 또한 이 요청이 다른 체인에 적용될 때는 <code>n</code>만 증가시킵니다. 부모 체인에서의 exit(혹은 자식 체인에서의 enter)의 경우는 반대로 수행합니다.</p>
<p>상태 변수를 1개 더 사용하고 컨트랙트 구현에 다소 복잡해지는 것과 <code>n</code>이 감소하는 경우를 trade-off 합니다.</p>
<p><img src="https://i.imgur.com/CZ6DnAG.png" alt=""></p>
<pre><code class="hljs css language-solidity"><span class="hljs-attr">pragma</span> <span class="hljs-string">solidity ^0.4.24;</span>

<span class="hljs-attr">...</span>

<span class="hljs-attr">contract</span> <span class="hljs-string">TrackableCounter is BaseCounter, RequestableI {</span>
  <span class="hljs-attr">...</span>

  <span class="hljs-meta">//</span> <span class="hljs-string">previous count before enter request in root chain and exit request in child chain.</span>
  <span class="hljs-attr">uint</span> <span class="hljs-string">public requestableN;</span>

  <span class="hljs-attr">...</span>

  <span class="hljs-meta">///</span> <span class="hljs-string">@dev override BaseCounter.count function.</span>
  <span class="hljs-attr">function</span> <span class="hljs-string">count() external {</span>
    <span class="hljs-attr">requestableN++;</span>
    <span class="hljs-attr">n++;</span>
    <span class="hljs-attr">emit</span> <span class="hljs-string">Counted(n);</span>
  <span class="hljs-attr">}</span>

  <span class="hljs-attr">function</span> <span class="hljs-string">applyRequestInRootChain(</span>
    <span class="hljs-attr">bool</span> <span class="hljs-string">isExit,</span>
    <span class="hljs-attr">uint256</span> <span class="hljs-string">requestId,</span>
    <span class="hljs-attr">address</span> <span class="hljs-string">requestor,</span>
    <span class="hljs-attr">bytes32</span> <span class="hljs-string">trieKey,</span>
    <span class="hljs-attr">bytes</span> <span class="hljs-string">trieValue</span>
  <span class="hljs-meta">)</span> <span class="hljs-string">external returns (bool success) {</span>
    <span class="hljs-attr">...</span>

    <span class="hljs-attr">uint</span> <span class="hljs-string">_n = trieValue.toUint()</span>
    <span class="hljs-attr">if</span> <span class="hljs-string">(isExit) {</span>
      <span class="hljs-attr">n</span> = <span class="hljs-string">n.add(_n);</span>
    <span class="hljs-meta">}</span> <span class="hljs-string">else {</span>
      <span class="hljs-attr">requestableN</span> = <span class="hljs-string">requestableN.sub(_n);</span>
    <span class="hljs-attr">}</span>

    <span class="hljs-attr">...</span>
  <span class="hljs-attr">}</span>

  <span class="hljs-attr">function</span> <span class="hljs-string">applyRequestInChildChain(</span>
    <span class="hljs-attr">bool</span> <span class="hljs-string">isExit,</span>
    <span class="hljs-attr">uint256</span> <span class="hljs-string">requestId,</span>
    <span class="hljs-attr">address</span> <span class="hljs-string">requestor,</span>
    <span class="hljs-attr">bytes32</span> <span class="hljs-string">trieKey,</span>
    <span class="hljs-attr">bytes</span> <span class="hljs-string">trieValue</span>
  <span class="hljs-meta">)</span> <span class="hljs-string">external returns (bool success) {</span>
    <span class="hljs-attr">...</span>

    <span class="hljs-attr">if</span> <span class="hljs-string">(isExit) {</span>
      <span class="hljs-attr">requestableN</span> = <span class="hljs-string">requestableN.sub(_n);</span>
    <span class="hljs-meta">}</span> <span class="hljs-string">else {</span>
      <span class="hljs-attr">n</span> = <span class="hljs-string">n.add(_n);</span>
    <span class="hljs-attr">}</span>

    <span class="hljs-attr">...</span>
  <span class="hljs-attr">}</span>
<span class="hljs-attr">}</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="token"></a><a href="#token" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Token</h2>
<p>ERC20 토큰 컨트랙트의 경우 <code>balances[holder]</code> 변수에 대하여 <a href="#simplecounter">SimpleCounter</a>와 <a href="#freezablecounter">FreezableCounter</a> 방식 두 가지로 작성할 수 있습니다. <code>SimpleCounter</code> 방식은 자식 체인에서 발행된 토큰은 언제나 부모 체인으로 exit 될 수 있지만, <code>FreezableCounter</code> 방식은 언제나 exit 되는 토큰의 수량만큼 부모 체인에서 묶여있어야 합니다. 본 문서에선 <code>SimpleCounter</code> 방식만을 다룹니다.</p>
<h3><a class="anchor" aria-hidden="true" id="requestablesimpletoken"></a><a href="#requestablesimpletoken" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RequestableSimpleToken</h3>
<p>(<a href="https://github.com/Onther-Tech/requestable-simple-token/blob/master/contracts/RequestableSimpleToken.sol">github</a>)</p>
<p><code>RequestableSimpleToken</code>는 <code>owner</code>가 토큰을 발행하고 일반 토큰 홀더가 자신의 토큰을 다른이에게 전송하거나 요청을 생성할 수 있는 컨트랙트입니다.</p>
<pre><code class="hljs css language-solidity">contract RequestableSimpleToken <span class="hljs-keyword">is</span> Ownable, RequestableI {
  <span class="hljs-keyword">using</span> SafeMath <span class="hljs-keyword">for</span> *;

  <span class="hljs-comment">// `owner` is stored at bytes32(0).</span>
  <span class="hljs-comment">// address owner; from Ownable</span>

  <span class="hljs-comment">// `totalSupply` is stored at bytes32(1).</span>
  <span class="hljs-keyword">uint</span> <span class="hljs-keyword">public</span> totalSupply;

  <span class="hljs-comment">// `balances[addr]` is stored at keccak256(bytes32(addr), bytes32(2)).</span>
  mapping(address =&gt; <span class="hljs-keyword">uint</span>) <span class="hljs-keyword">public</span> balances;

  <span class="hljs-comment">// requests</span>
  mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) appliedRequests;

  bytes32 constant <span class="hljs-keyword">public</span> KEY_OWNER         = <span class="hljs-number">0x0000000000000000000000000000000000000000000000000000000000000000</span>;
  bytes32 constant <span class="hljs-keyword">public</span> KEY_TOTAL_SUPPLY  = <span class="hljs-number">0x0000000000000000000000000000000000000000000000000000000000000001</span>;
  bytes32 constant <span class="hljs-keyword">public</span> PERFIX_BALANCES   = <span class="hljs-number">0x0000000000000000000000000000000000000000000000000000000000000002</span>;

  <span class="hljs-comment">/* Events */</span>
  <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Transfer</span>(<span class="hljs-params">address _from, address _to, <span class="hljs-keyword">uint</span> _value</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Mint</span>(<span class="hljs-params">address _to, <span class="hljs-keyword">uint</span> _value</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">Requested</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> _isExit, address _requestor, bytes32 _trieKey, bytes _trieValue</span>)</span>;

  <span class="hljs-function">function <span class="hljs-title">transfer</span>(<span class="hljs-params">address _to, <span class="hljs-keyword">uint</span> _value</span>) <span class="hljs-keyword">public</span></span> {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].<span class="hljs-keyword">add</span>(_value);

    <span class="hljs-function">emit <span class="hljs-title">Transfer</span>(<span class="hljs-params">msg.sender, _to, _value</span>)</span>;
  }

  <span class="hljs-function">function <span class="hljs-title">mint</span>(<span class="hljs-params">address _to, <span class="hljs-keyword">uint</span> _value</span>) <span class="hljs-keyword">public</span> onlyOwner</span> {
    totalSupply = totalSupply.<span class="hljs-keyword">add</span>(_value);
    balances[_to] = balances[_to].<span class="hljs-keyword">add</span>(_value);

    <span class="hljs-function">emit <span class="hljs-title">Mint</span>(<span class="hljs-params">_to, _value</span>)</span>;
    <span class="hljs-function">emit <span class="hljs-title">Transfer</span>(<span class="hljs-params">address(<span class="hljs-number">0</span></span>), _to, _value)</span>;
  }

  <span class="hljs-comment">// User can get the trie key of one's balance and make an enter request directly.</span>
  <span class="hljs-function">function <span class="hljs-title">getBalanceTrieKey</span>(<span class="hljs-params">address who</span>) <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params">bytes32</span>)</span> {
    <span class="hljs-keyword">return</span> keccak256(abi.encodePacked(bytes32(bytes20(who)), PERFIX_BALANCES));
  }

  <span class="hljs-function">function <span class="hljs-title">applyRequestInRootChain</span>(<span class="hljs-params">
    <span class="hljs-keyword">bool</span> isExit,
    uint256 requestId,
    address requestor,
    bytes32 trieKey,
    bytes calldata trieValue
  </span>) external <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-keyword">bool</span> success</span>)</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> adpot RootChain</span>
    <span class="hljs-comment">// require(msg.sender == address(rootchain));</span>

    require(!appliedRequests[requestId]);

    <span class="hljs-keyword">if</span> (isExit) {
      <span class="hljs-keyword">if</span> (KEY_OWNER == trieKey) {
        <span class="hljs-comment">// only owner (in child chain) can exit `owner` variable.</span>
        <span class="hljs-comment">// but it is checked in applyRequestInChildChain and exitChallenge.</span>

        <span class="hljs-comment">// set requestor as owner in root chain.</span>
        _transferOwnership(requestor);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (KEY_TOTAL_SUPPLY == trieKey) {
        <span class="hljs-comment">// no one can exit `totalSupply` variable.</span>
        <span class="hljs-comment">// but do nothing to return true.</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceTrieKey(requestor) == trieKey) {
        <span class="hljs-comment">// this checks trie key equals to `balances[requestor]`.</span>
        <span class="hljs-comment">// only token holder can exit one's token.</span>
        <span class="hljs-comment">// exiting means moving tokens from child chain to root chain.</span>
        balances[requestor] += decodeTrieValue(trieValue);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// cannot exit other variables.</span>
        <span class="hljs-comment">// but do nothing to return true.</span>
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// apply enter</span>
      <span class="hljs-keyword">if</span> (KEY_OWNER == trieKey) {
        <span class="hljs-comment">// only owner (in root chain) can enter `owner` variable.</span>
        require(owner() == requestor);
        <span class="hljs-comment">// do nothing in root chain</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (KEY_TOTAL_SUPPLY == trieKey) {
        <span class="hljs-comment">// no one can enter `totalSupply` variable.</span>
        revert();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceTrieKey(requestor) == trieKey) {
        <span class="hljs-comment">// this checks trie key equals to `balances[requestor]`.</span>
        <span class="hljs-comment">// only token holder can enter one's token.</span>
        <span class="hljs-comment">// entering means moving tokens from root chain to child chain.</span>
        require(balances[requestor] &gt;= decodeTrieValue(trieValue));
        balances[requestor] -= decodeTrieValue(trieValue);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// cannot apply request on other variables.</span>
        revert();
      }
    }

    appliedRequests[requestId] = <span class="hljs-literal">true</span>;

    <span class="hljs-function">emit <span class="hljs-title">Requested</span>(<span class="hljs-params">isExit, requestor, trieKey, trieValue</span>)</span>;

    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> adpot RootChain</span>
    <span class="hljs-comment">// setRequestApplied(requestId);</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// this is only called by NULL_ADDRESS in child chain</span>
  <span class="hljs-comment">// when i) exitRequest is initialized by startExit() or</span>
  <span class="hljs-comment">//     ii) enterRequest is initialized</span>
  <span class="hljs-function">function <span class="hljs-title">applyRequestInChildChain</span>(<span class="hljs-params">
    <span class="hljs-keyword">bool</span> isExit,
    uint256 requestId,
    address requestor,
    bytes32 trieKey,
    bytes calldata trieValue
  </span>) external <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-keyword">bool</span> success</span>)</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> adpot child chain</span>
    <span class="hljs-comment">// require(msg.sender == NULL_ADDRESS);</span>
    require(!appliedRequests[requestId]);

    <span class="hljs-keyword">if</span> (isExit) {
      <span class="hljs-keyword">if</span> (KEY_OWNER == trieKey) {
        <span class="hljs-comment">// only owner (in child chain) can exit `owner` variable.</span>
        require(owner() == requestor);

        <span class="hljs-comment">// do nothing when exit `owner` in child chain</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (KEY_TOTAL_SUPPLY == trieKey) {
        <span class="hljs-comment">// no one can exit `totalSupply` variable.</span>
        revert();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceTrieKey(requestor) == trieKey) {
        <span class="hljs-comment">// this checks trie key equals to `balances[tokenHolder]`.</span>
        <span class="hljs-comment">// only token holder can exit one's token.</span>
        <span class="hljs-comment">// exiting means moving tokens from child chain to root chain.</span>

        <span class="hljs-comment">// revert provides a proof for `exitChallenge`.</span>
        require(balances[requestor] &gt;= decodeTrieValue(trieValue));

        balances[requestor] -= decodeTrieValue(trieValue);
      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// cannot exit other variables.</span>
        revert();
      }
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// apply enter</span>
      <span class="hljs-keyword">if</span> (KEY_OWNER == trieKey) {
        <span class="hljs-comment">// only owner (in root chain) can make enterRequest of `owner` variable.</span>
        <span class="hljs-comment">// but it is checked in applyRequestInRootChain.</span>

        _transferOwnership(requestor);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (KEY_TOTAL_SUPPLY == trieKey) {
        <span class="hljs-comment">// no one can enter `totalSupply` variable.</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceTrieKey(requestor) == trieKey) {
        <span class="hljs-comment">// this checks trie key equals to `balances[tokenHolder]`.</span>
        <span class="hljs-comment">// only token holder can enter one's token.</span>
        <span class="hljs-comment">// entering means moving tokens from root chain to child chain.</span>
        balances[requestor] += decodeTrieValue(trieValue);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// cannot apply request on other variables.</span>
        revert();
      }
    }

    appliedRequests[requestId] = <span class="hljs-literal">true</span>;

    <span class="hljs-function">emit <span class="hljs-title">Requested</span>(<span class="hljs-params">isExit, requestor, trieKey, trieValue</span>)</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function">function <span class="hljs-title">decodeTrieValue</span>(<span class="hljs-params">bytes memory trieValue</span>) <span class="hljs-keyword">public</span> pure <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-keyword">uint</span> v</span>)</span> {
    require(trieValue.length == <span class="hljs-number">0x20</span>);

    assembly {
       v := mload(<span class="hljs-keyword">add</span>(trieValue, <span class="hljs-number">0x20</span>))
    }
  }
}
</code></pre>
<p>OpenZeppelin과 ds-token 기반의 requestable 토큰 컨트랙트는 다음에서 확인할 수 있습니다.</p>
<ul>
<li><a href="https://github.com/Onther-Tech/requestable-erc20-wrapper-token/blob/master/contracts/RequestableERC20Wrapper.sol">RequestableERC20WrapperToken</a></li>
<li><a href="https://github.com/Onther-Tech/requestable-ds-wrapper-token">requestable-ds-wrapper-token</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="requestable-cryptokitties"></a><a href="#requestable-cryptokitties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Requestable CryptoKitties</h3>
<blockquote>
<p>이 항목에 대한 자세한 설명은 <a href="https://medium.com/onther-tech/cryptokitties-in-plasma-574159c581dc">여기</a>서 확인할 수 있습니다.</p>
</blockquote>
<p><img src="https://miro.medium.com/max/570/1*8GIz9Ovmdq-bQRMjQDkrIw.png" alt=""></p>
<p><a href="https://github.com/cryptocopycats/awesome-cryptokitties">CryptoKitties</a>에서 실제로 배포되는 컨트랙트는 <code>KittyCore</code>, <code>SaleClockAuction</code>, <code>SiringClockAuction</code>으로 ERC721 토큰으로서의 기능은 <code>KittyCore</code>가 담당합니다.</p>
<p>CryptoKitties의 상태변수에 대한 요청은 다음과 같은 방식으로 정리할 수 있습니다.</p>
<ul>
<li><code>KittyAccessControll.paused</code>: only enter by anyone</li>
<li><code>KittyAccessControll.ceoAddress</code>: only enter by anyone</li>
<li><code>KittyAccessControll.cfoAddress</code>: only enter by anyone</li>
<li><code>KittyAccessControll.cooAddress</code>: only enter by anyone</li>
<li><code>KittyBreeding.autoBirthFee</code>: only enter by anyone</li>
</ul>
<p>위 변수들은 루트체인에서 자식체인으로 enter 만 허용함으로서 권한을 일방향으로 강제할 수 있습니다.</p>
<ul>
<li><code>KittyBase.kitties</code>: enter or exit by anyone</li>
<li><code>KittyBase.kittyIndexToOwner</code>: enter and exit by kitty owner</li>
</ul>
<p>개별 키티의 데이터를 가지고있는 kitties 변수는 누구나 request할 수 있도록 허용하며, 해당 키티의 소유자만이 소유권에 대한 request를 만들 수 있어야 합니다.</p>
<ul>
<li><code>KittyBase.kittyIndexToApproved</code>: non-requestable.</li>
<li><code>KittyBase.ownershipTokenCount</code>: non-requestable.</li>
<li><code>KittyBase.sireAllowedToAddress</code>: non-requestable</li>
</ul>
<p>위 변수들은 transfer() 함수에서 소유권의 이전과 함께 삭제되는 값들입니다. 직접적인 request 대상이 되지 않습니다.</p>
<ul>
<li><code>KittyBreeding.pregnantKitties</code>: Pregenent Kitty Ownership Request enter / exit 시 증감</li>
</ul>
<p>임신한 키티의 소유권을 다른 체인으로 이동시킬 때 증감시킵니다.</p>
<ul>
<li><code>KittyBase.saleAuction</code>: non-requestable. set by CEO</li>
<li><code>KittyBase.siringAuction</code>: non-requestable. set by CEO</li>
<li><code>KittyBreeding.geneScience</code>: non-requestable. set by CEO</li>
<li><code>KittyCore.newContractAddress</code>: non-requestable. set by CEO</li>
</ul>
<p>외부 컨트랙트의 주소들은 오직 CEO만 설정 가능하기에 requestable 하지 않습니다.</p>
<ul>
<li><code>KittyMinting.promoCreatedCount</code>: only enter by anyone</li>
<li><code>KittyMinting.gen0CreatedCount</code>: only enter by anyone</li>
</ul>
<p>위 두 값들은 단순한 상수로 누구나 requestable 해야 합니다.</p>
<h2><a class="anchor" aria-hidden="true" id="requestablemultisig"></a><a href="#requestablemultisig" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RequestableMultisig</h2>
<blockquote>
<p>이 예제는 실제 환경에서 사용하기 마시기 바랍니다.</p>
</blockquote>
<p>(<a href="https://github.com/Onther-Tech/requestable-multisig">github</a>)</p>
<p><code>RequestableMultisig</code>는 <a href="https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol">MultiSigWallet</a>를 requestable하게 변경한 컨트랙트입니다.</p>
<p><code>RequestableMultisig</code>는 멀티 시그 컨트랙트가 보낼 트랜잭션 데이터를 <code>Transaction</code> 구조체와 <code>transactions</code> 변수로 관리합니다. 그리고 해당 트랜잭션에 대한 서명을 <code>confirmations</code> 변수로 수집한 후 이것이 정족수(<code>_required</code>)를 넘으면 실행됩니다. out-of-gas와 같은 에러가 발생할 경우 다시 실행이 가능하며, 올바르기 실행된 경우 <code>executed</code> 변수에 결과를 반영합니다. 따라서 <code>RequestableMultisig</code>의 요청은 다음으로 나누어집니다.</p>
<h3><a class="anchor" aria-hidden="true" id="1-transactions"></a><a href="#1-transactions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. <code>transactions</code></h3>
<p><code>trieValue</code>는 RLP 인코딩된 Transaction 데이터입니다. 이 요청은 단순하게 양 체인간의 데이터를 동일하게 유지하는 기능을 합니다. <code>submitTransaction</code> 함수가 트랜잭션 데이터를 등록하고 confirm을 하는데, 이 요청은 confirm 과정을 제외하고 순수하게 데이터만 등록합니다. 이는 <code>owner</code>만이 <code>submitTransaction</code>를 호출할 수 있다는 점과 차이를 가집니다.</p>
<pre><code class="hljs css language-solidity"><span class="hljs-constructor">_handleTransaction(<span class="hljs-params">isRootChain</span>, <span class="hljs-params">isExit</span>, <span class="hljs-params">toTransaction</span>(<span class="hljs-params">trieValue</span>)</span>);

<span class="hljs-keyword">function</span> <span class="hljs-constructor">_handleTransaction(<span class="hljs-params">bool</span> <span class="hljs-params">isRootChain</span>, <span class="hljs-params">bool</span> <span class="hljs-params">isExit</span>, Transaction <span class="hljs-params">memory</span> <span class="hljs-params">transaction</span>)</span> internal {
  bytes32 transactionId = hash(transaction);

  <span class="hljs-comment">// transaction check</span>
  <span class="hljs-comment">//                          isRootChain == true       isRootChain == false</span>
  <span class="hljs-comment">//                       +--------------------------------------------------</span>
  <span class="hljs-comment">//     enter request     |  must be added         |  must not be added</span>
  <span class="hljs-comment">//     exit request      |  must not be added     |  must be added</span>

  <span class="hljs-keyword">if</span> (isRootChain<span class="hljs-operator"> &amp;&amp; </span>!isExit<span class="hljs-operator"> || </span>!isRootChain<span class="hljs-operator"> &amp;&amp; </span>isExit) {
    require(transactions<span class="hljs-literal">[<span class="hljs-identifier">transactionId</span>]</span>.added);
  } <span class="hljs-keyword">else</span> {
    require(!transactions<span class="hljs-literal">[<span class="hljs-identifier">transactionId</span>]</span>.added);
    add<span class="hljs-constructor">Transaction(<span class="hljs-params">transaction</span>.<span class="hljs-params">destination</span>, <span class="hljs-params">transaction</span>.<span class="hljs-params">value</span>, <span class="hljs-params">transaction</span>.<span class="hljs-params">data</span>)</span>;
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="2-executed"></a><a href="#2-executed" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. <code>executed</code></h3>
<p>한 쪽 체인에서 실행된 트랜잭션은 다른 체인에서 동일하게 실행되어선 안됩니다. <code>executed</code> 변수에 대한 요청은 실행된 트랜잭션에 대해 중복으로 처리되는 것읆 방지합니다.</p>
<pre><code class="hljs css language-solidity"><span class="hljs-constructor">_handleExecuted(<span class="hljs-params">isExit</span>, <span class="hljs-params">trieValue</span>.<span class="hljs-params">toBytes32</span>()</span>);

<span class="hljs-keyword">function</span> <span class="hljs-constructor">_handleExecuted(<span class="hljs-params">bool</span> <span class="hljs-params">isExit</span>, <span class="hljs-params">bytes32</span> <span class="hljs-params">transactionId</span>)</span>
  internal
{
  <span class="hljs-comment">// short circuit if transaction is already executed for exit request.</span>
  require(!isExit<span class="hljs-operator"> || </span>!executed<span class="hljs-literal">[<span class="hljs-identifier">transactionId</span>]</span>);
  executed<span class="hljs-literal">[<span class="hljs-identifier">transactionId</span>]</span> = <span class="hljs-literal">true</span>;
  emit <span class="hljs-constructor">ExecutionAdded(<span class="hljs-params">transactionId</span>)</span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="3-new--revoked-confirmations"></a><a href="#3-new--revoked-confirmations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. New / Revoked <code>confirmations</code></h3>
<p><code>confirmTransaction</code> 함수에 대응하는 &quot;새로운 <code>confirmations</code> 변수에 대한 요청&quot;은 <code>owner</code>의 새로운 confirm을 다른 체인에 반영하는 요청입니다. 이는 실행되지 않은 트랜잭션에 대해서 <code>executed</code>에 대한 요청과 마찬가지로 confirm을 통한 트랜잭션의 실행을 방지합니다.</p>
<pre><code class="hljs">_handleNewConfirmation(isRootChain, isExit, requestor, trieValue.toBytes32());

<span class="hljs-keyword">function</span> _handleNewConfirmation(
  bool isRootChain,
  bool isExit,
  address requestor,
  bytes32 transactionId
)
  internal
  notExecuted(transactionId)
{
  <span class="hljs-regexp">//</span> check ownership <span class="hljs-keyword">for</span> <span class="hljs-keyword">exit</span> request.
  require(!isExit || isOwner[requestor]);

  <span class="hljs-regexp">//</span> confirmation check
  <span class="hljs-regexp">//</span>                          isRootChain == true       isRootChain == false
  <span class="hljs-regexp">//</span>                       +--------------------------------------------------
  <span class="hljs-regexp">//</span>     enter request     |  must be confirmed      |  must not be confirmed
  <span class="hljs-regexp">//</span>     <span class="hljs-keyword">exit</span> request      |  must not be confirmed  |  must be confirmed
  <span class="hljs-keyword">if</span> (isRootChain &amp;&amp; !isExit || !isRootChain &amp;&amp; isExit) {
    require(confirmations[transactionId][requestor]);
    confirmations[transactionId][requestor] = false;
  } <span class="hljs-keyword">else</span> {
    require(!confirmations[transactionId][requestor]);
    confirmations[transactionId][requestor] = true;
    emit Confirmation(requestor, transactionId);
  }
}
</code></pre>
<p><code>revokeConfirmation</code> 함수에 대응하는 &quot;제거된 <code>confirmations</code> 변수에 대한 요청&quot;은 이전과 반대의 기능을 합니다.</p>
<pre><code class="hljs">_handleRevokedConfirmation(isRootChain, isExit, requestor, trieValue.toBytes32());

<span class="hljs-keyword">function</span> _handleRevokedConfirmation(
  bool isRootChain,
  bool isExit,
  address requestor,
  bytes32 transactionId
)
  internal
  notExecuted(transactionId)
{
  <span class="hljs-regexp">//</span> check ownership <span class="hljs-keyword">for</span> <span class="hljs-keyword">exit</span> request.
  require(!isExit || isOwner[requestor]);

  <span class="hljs-regexp">//</span> confirmation check
  <span class="hljs-regexp">//</span>                          isRootChain == true       isRootChain == false
  <span class="hljs-regexp">//</span>                       +--------------------------------------------------
  <span class="hljs-regexp">//</span>     enter request     |  must be not confirmed  |  must be confirmed
  <span class="hljs-regexp">//</span>     <span class="hljs-keyword">exit</span> request      |  must be confirmed      |  must not be confirmed
  <span class="hljs-keyword">if</span> (isRootChain &amp;&amp; !isExit || !isRootChain &amp;&amp; isExit) {
    require(!confirmations[transactionId][requestor]);
  } <span class="hljs-keyword">else</span> {
    require(confirmations[transactionId][requestor]);
    confirmations[transactionId][requestor] = false;
    emit Revocation(requestor, transactionId);
  }
}
</code></pre>
<blockquote>
<p>&quot;새로운 <code>confirmations</code> 변수에 대한 요청&quot;과 제거된 <code>confirmations</code> 변수에 대한 요청은 별도의 <code>trieKey</code>로 반드시 구분지을 필요는 없습니다. 두 개의 요청을 하나의 요청으로 축소시키고, <code>trieValue</code>를 <code>RLP.encode(transactionId, isNew)</code>와 같은 방식으로 사용할 수 도 있습니다.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="4-new--removed-owners"></a><a href="#4-new--removed-owners" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. New / Removed <code>owners</code></h3>
<p>새로운 <code>owner</code> 혹은 제거된 <code>owner</code>에 대한 요청입니다.</p>
<pre><code class="hljs">  <span class="hljs-keyword">function</span> <span class="hljs-constructor">_handleNewOwner(<span class="hljs-params">bool</span> <span class="hljs-params">isRootChain</span>, <span class="hljs-params">bool</span> <span class="hljs-params">isExit</span>, <span class="hljs-params">address</span> <span class="hljs-params">owner</span>)</span> internal {
    <span class="hljs-keyword">if</span> (isRootChain<span class="hljs-operator"> &amp;&amp; </span>!isExit<span class="hljs-operator"> || </span>!isRootChain<span class="hljs-operator"> &amp;&amp; </span>isExit) {
      require(isOwner<span class="hljs-literal">[<span class="hljs-identifier">owner</span>]</span>);
    } <span class="hljs-keyword">else</span> {
      this.add<span class="hljs-constructor">Owner(<span class="hljs-params">owner</span>)</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-constructor">_handleRemovedOwner(<span class="hljs-params">bool</span> <span class="hljs-params">isRootChain</span>, <span class="hljs-params">bool</span> <span class="hljs-params">isExit</span>, <span class="hljs-params">address</span> <span class="hljs-params">owner</span>)</span> internal {
    <span class="hljs-keyword">if</span> (isRootChain<span class="hljs-operator"> &amp;&amp; </span>!isExit<span class="hljs-operator"> || </span>!isRootChain<span class="hljs-operator"> &amp;&amp; </span>isExit) {
      require(!isOwner<span class="hljs-literal">[<span class="hljs-identifier">owner</span>]</span>);
    } <span class="hljs-keyword">else</span> {
      this.remove<span class="hljs-constructor">Owner(<span class="hljs-params">owner</span>)</span>;
    }
  }
</code></pre>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2019-12-20 by 4000D</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/learn/advanced/plasma-evm-smart-contracts"><span class="arrow-prev">← </span><span>Plasma EVM 스마트 컨트랙트</span></a><a class="docs-next button" href="/docs/guides/getting-started/how-to-open-private-testnet-rootchain"><span>루트체인 설정하기</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#counter">Counter</a><ul class="toc-headings"><li><a href="#basecounter">BaseCounter</a></li><li><a href="#simplecounter">SimpleCounter</a></li><li><a href="#freezablecounter">FreezableCounter</a></li><li><a href="#trackablecounter">TrackableCounter</a></li></ul></li><li><a href="#token">Token</a><ul class="toc-headings"><li><a href="#requestablesimpletoken">RequestableSimpleToken</a></li><li><a href="#requestable-cryptokitties">Requestable CryptoKitties</a></li></ul></li><li><a href="#requestablemultisig">RequestableMultisig</a><ul class="toc-headings"><li><a href="#1-transactions">1. <code>transactions</code></a></li><li><a href="#2-executed">2. <code>executed</code></a></li><li><a href="#3-new--revoked-confirmations">3. New / Revoked <code>confirmations</code></a></li><li><a href="#4-new--removed-owners">4. New / Removed <code>owners</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div><h5>Docs</h5><a href="/docs/learn/basic/tokamak-network">배우기</a><a href="/docs/en/guides/getting-started/how-to-open-private-testnet-rootchain">가이드</a></div><div><h5>Community</h5><a href="https://chat.tokamak.network/">Chat Tokemak</a><a href="https://twitter.com/ontherinfo" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="http://blog.onther.io">Onther Blog</a><a href="https://github.com/onther-tech/">Onther GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/onther-tech/plasma-evm" data-show-count="true" data-count-aria-label="# plasma-evm on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://tokamak.network" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/tokamak_white.png" alt="Tokamak Network" width="200%" height="200%"/></a><section class="copyright">Copyright © 2019 Onther Inc.</section></footer></div></body></html>